<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Multiplayer game</title>
	<style>
		span {
			font-style: italic;
		}
		#start:not([hidden]), #play:not([hidden]) {
			display: flex;
			justify-content: center;
		}
		#chatbox {
			border: 1px solid black;
			display: flex;
			flex-direction: column-reverse;
			position: absolute;
			top: 0;
			bottom: 20px;
			left: 0;
			right: 0;
			overflow: auto;
		}
		#chatcontainer {
			position: relative;
			width: 25%;
		}
		canvas {
			width: 75%;
			border: 5px solid rgb(0, 255, 0);
		}
		#chatinput {
			position: absolute;
			bottom: 0;
			width: -moz-available;
			width: -webkit-fill-available;
		}
		#chatbox p {
			margin: 0.5em;
		}
	</style>
</head>

<body>
	<div id="start">
		<label>Choose a display name:
			<input id="displayname" maxlength="30">
		</label>
	</div>
	<div id="play" hidden>
		<canvas width="3000" height="2000" id="canvas"></canvas>
		<div id="chatcontainer">
			<div id="chatbox"></div>
			<input id="chatinput">
		</div>
	</div>
</body>

<script>
'use strict';

{
	const [chatbox, chatinput, usernameinput, play, start_screen, canvas] =
		['chatbox', 'chatinput', 'displayname', 'play', 'start', 'canvas']
			.map(document.getElementById.bind(document)),
		keys = new Set([
			'ArrowUp',
			'ArrowLeft',
			'ArrowDown',
			'ArrowRight'
		]),
		keys_down = new Set,
		players = new Map,
		dead_guys = new Set,
		ctx = canvas.getContext('2d'),
		scale = 10;

	ctx.imageSmoothingEnabled = false;
	ctx.textAlign = 'center';
	ctx.font = '5px arial';

	players.set_property = function (id, property, value) {
		const player = this.get(id);
		if (player) player[property] = value;
		else this.set(id, { [property]: value });
	}

	usernameinput.value = localStorage.display_name || '';
	usernameinput.select();
	usernameinput.addEventListener('keydown', ({ key }) => {
		if (key === 'Enter') start();
	});

	let ws, walls = [], my_id, angle = 0, playing = false;

	function start() {
		playing = true;
		if (!ws) setup();
		else {
			chatinput.disabled = false;
			ws.send(JSON.stringify({
				type: 'restart',
				username: localStorage.display_name = usernameinput.value
			}));
		}
		play.hidden = false;
		start_screen.hidden = true;
	}

	function setup() {
		play.hidden = false;
		ws = new WebSocket(
			`ws://${
				location.hostname
			}:${
				window.location.port ||
					(window.location.protocol === 'http:' ? '80' : '443')
			}/?username=${
				encodeURIComponent(
					localStorage.display_name = usernameinput.value)
			}`);

		document.addEventListener('keydown', e => handle_key(e, true));
		document.addEventListener('keyup', e => handle_key(e, false));

		ws.onmessage = ({ data }) => {
			const { type, message, username, color, id } = JSON.parse(data);
			if (type === 'message') {
				append_chat(message, players.get(id).username);
			} else if (type === 'position') {
				if (username !== undefined) {
					players.set_property(id, 'username', username);
				}
				if (color) players.set_property(id, 'color', color);
				if (id === my_id) {
					ctx.setTransform(scale, 0, 0, scale,
						canvas.width  / 2 - message[0] * scale,
						canvas.height / 2 - message[1] * scale);
				}
				players.set_property(id, 'position', message);
				update();
			} else if (type === 'id') {
				my_id = id;
				players.set_property(id, 'username', usernameinput.value);
			} else if (type === 'bye') {
				players.delete(id);
				update();
			} else if (type === 'wall') {
				walls = message;
				update();
			} else if (type === 'die') {
				const player = players.get(id);
				player.death_date = Date.now();
				dead_guys.add(player);
				players.delete(id);
				if (id === my_id) {
					playing = false;	
					chatinput.disabled = true;
					start_screen.hidden = false;
					usernameinput.select();
				}
				setTimeout(() => dead_guys.delete(player), 1000);
				update();
			}
		}

		function update() {
			ctx.save();
			ctx.resetTransform();
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.restore();

			for (const wall of walls) {
				ctx.fillRect(...wall);
			}

			for (const { position, color } of iterator()) {
				if (!position) continue;
				ctx.fillStyle = color || '#000000';
				ctx.beginPath();
				ctx.arc(...position, 5, 0, 2 * Math.PI);
				ctx.fill();
			}

			ctx.globalAlpha = 1;

			for (const { username, position, color } of iterator()) {
				if (!position || !username) continue;
				ctx.fillStyle = color || '#000000';
				ctx.fillText(username, position[0], position[1] - 6);
			}
			ctx.fillStyle = '#000000';
			ctx.globalAlpha = 1;

			const me = players.get(my_id);
			if (me && me.position) {
				const [x, y] = me.position;
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + Math.cos(angle) * 5, y + Math.sin(angle) * 5);
				ctx.stroke();
			}

			function* iterator() {
				yield* players.values();
				for (const player of dead_guys) {
					ctx.globalAlpha = 1 - (Date.now() - player.death_date) / 1000;
					yield player;
				}
			}
		}

		function chat_listener({ key }) {
			if (key === 'Enter') {
				ws.send(JSON.stringify({
					type: 'message',
					message: chatinput.value
				}));
				append_chat(chatinput.value);
				chatinput.value = '';
			}
		}

		chatinput.addEventListener('keydown', chat_listener);

		function append_chat(text, username) {
			const elem = document.createElement('p');
			const name = document.createElement(username === undefined ? 'span' : 'b');
			name.textContent = (username === undefined ? '(You)' : username) + ': ';
			elem.appendChild(name);
			elem.insertAdjacentText('beforeend', text);
			chatbox.prepend(elem);
		}

		function handle_key(event, is_down) {
			if (keys.has(event.code)) {
				keys_down[is_down ? 'add' : 'delete'](event.code);
				if (!playing) return;
				event.preventDefault();
				let accel = 0;
				if (keys_down.has('ArrowUp')) accel++;
				if (keys_down.has('ArrowDown')) accel--;
				ws.send(JSON.stringify({
					type: 'position',
					x: Math.cos(angle) * accel,
					y: Math.sin(angle) * accel
				}));
			} else if (event.target !== chatinput && playing) chatinput.select();
		}

		setInterval(() => {
			if (keys_down.has('ArrowLeft'))  angle -= Math.PI / 10;
			if (keys_down.has('ArrowRight')) angle += Math.PI / 10;
		}, 100);
	}
}
</script>

</html>