<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="
		A multiplayer game where players use the arrow keys to navigate a
		maze and knock other players into walls.">
	<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
	<title>Multiplayer game</title>
	<style>
		span {
			font-style: italic;
		}
		#play:not([hidden]) {
			display: flex;
			justify-content: center;
		}
		body {
			display: flex;
			justify-content: center;
			align-items: center;
			flex-direction: column;
		}
		#chatbox {
			border: 1px solid black;
			display: flex;
			flex-direction: column-reverse;
			position: absolute;
			top: 0;
			bottom: 20px;
			left: 0;
			right: 0;
			overflow: auto;
		}
		#chatcontainer {
			position: relative;
			width: 25%;
		}
		canvas {
			width: 75%;
			border: 5px solid rgb(0, 255, 0);
		}
		#chatinput {
			position: absolute;
			bottom: 0;
			width: -moz-available;
			width: -webkit-fill-available;
		}
		#chatbox p {
			margin: 0.5em;
		}
	</style>
</head>

<body>
	<noscript>
		You must enable javascript to play this game.
	</noscript>
	<p id="start">
		<label>Choose a display name:
			<input id="displayname" maxlength="30">
		</label>
	</p>
	<div id="play" hidden>
		<canvas width="3000" height="2000" id="canvas"></canvas>
		<div id="chatcontainer">
			<div id="chatbox"></div>
			<input id="chatinput">
		</div>
	</div>
</body>

<script>
'use strict';

{
	const [chatbox, chatinput, usernameinput, play, start_screen, canvas] =
		['chatbox', 'chatinput', 'displayname', 'play', 'start', 'canvas']
			.map(document.getElementById.bind(document)),
		keys = new Set([
			'ArrowUp',
			'ArrowLeft',
			'ArrowDown',
			'ArrowRight'
		]),
		keys_down = new Set,
		players = new Map,
		dead_guys = new Set,
		ctx = canvas.getContext('2d'),
		scale = 10;

	let on_screen = new Set,
		treasure_pos,
		ws, my_id,
		walls = [],
		angle = 0,
		playing = false;

	ctx.imageSmoothingEnabled = false;
	ctx.textAlign = 'center';
	ctx.font = '5px arial';

	function set_property(id, property, value) {
		const player = players.get(id);
		if (player) player[property] = value;
		else players.set(id, { [property]: value });
	}

	usernameinput.value = localStorage.display_name || '';
	usernameinput.select();
	usernameinput.addEventListener('keydown', ({ key }) => {
		if (key === 'Enter') start();
	});

	function start() {
		playing = true;
		if (!ws) setup();
		else {
			ws.send(JSON.stringify({
				type: 'restart',
				username: localStorage.display_name = usernameinput.value
			}));
		}
		play.hidden = false;
		start_screen.hidden = true;
		resize();
	}

	function setup() {
		play.hidden = false;
		ws = new WebSocket(
			`ws://${
				location.hostname
			}:${
				window.location.port ||
					(window.location.protocol === 'http:' ? '80' : '443')
			}/?username=${
				encodeURIComponent(
					localStorage.display_name = usernameinput.value)
			}%s`);

		document.addEventListener('keydown', e => handle_key(e, true));
		document.addEventListener('keyup', e => handle_key(e, false));

		ws.onmessage = ({ data }) => {
			const { type, message, name, color, id, pos, treasure } = JSON.parse(data);
			if (type === 'message') {
				append_chat(message, players.get(id).username);
			} else if (type === 'player') {
				set_property(id, 'username', name);
				set_property(id, 'color', color);
			} else if (type === 'position') {
				on_screen = new Set();
				if (pos) on_screen.add(my_id);
				treasure_pos = treasure;
				for (const [id, pos] of message) {
					on_screen.add(id);
					set_property(id, 'position', pos);
				}
				if (pos) {
					set_property(my_id, 'position', pos);
					ctx.setTransform(scale, 0, 0, scale,
						canvas.width  / 2 - pos[0] * scale,
						canvas.height / 2 - pos[1] * scale);
				}
			} else if (type === 'id') {
				my_id = id;
				set_property(id, 'username', usernameinput.value);
			} else if (type === 'bye') {
				players.delete(id);
			} else if (type === 'wall') {
				walls = message;
			} else if (type === 'die') {
				const player = players.get(id);
				player.death_date = Date.now();
				dead_guys.add(player);
				players.delete(id);
				on_screen.delete(id);
				if (id === my_id) {
					playing = false;
					start_screen.hidden = false;
					usernameinput.select();
					resize();
				}
				setTimeout(() => dead_guys.delete(player), 1000);
			} else if (type === 'leave') {
				on_screen.delete(id);
			}
		}

		function update() {
			ctx.save();
			ctx.resetTransform();
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.restore();

			ctx.fillStyle = '#000000';

			for (const wall of walls) {
				ctx.fillRect(...wall);
			}

			for (const { position, color } of iterator()) {
				if (!position) continue;
				ctx.fillStyle = color || '#000000';
				ctx.beginPath();
				ctx.arc(...position, 5, 0, 2 * Math.PI);
				ctx.fill();
			}

			ctx.globalAlpha = 1;

			for (const { username, position, color } of iterator()) {
				if (!position || !username) continue;
				ctx.fillStyle = color || '#000000';
				ctx.fillText(username, position[0], position[1] - 6);
			}

			ctx.globalAlpha = 1;

			ctx.fillStyle = '#FFFF00';
			if (treasure_pos) ctx.fillRect(...treasure_pos, 10, 10)

			const me = players.get(my_id);
			if (me && me.position) {
				const [x, y] = me.position;
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + Math.cos(angle) * 5, y + Math.sin(angle) * 5);
				ctx.stroke();
			}

			function* iterator() {
				for (const id of on_screen) {
					yield players.get(id);
				}
				for (const player of dead_guys) {
					ctx.globalAlpha = 1 - (Date.now() - player.death_date) / 1000;
					yield player;
				}
			}
		}

		function chat_listener({ key }) {
			if (key === 'Enter') {
				ws.send(JSON.stringify({
					type: 'message',
					message: chatinput.value
				}));
				append_chat(chatinput.value);
				chatinput.value = '';
			}
		}

		chatinput.addEventListener('keydown', chat_listener);

		function append_chat(text, username) {
			const elem = document.createElement('p');
			const name = document.createElement(username === undefined ? 'span' : 'b');
			name.textContent = (username === undefined ? '(You)' : username) + ': ';
			elem.appendChild(name);
			elem.insertAdjacentText('beforeend', text);
			chatbox.prepend(elem);
		}

		function handle_key(event, is_down) {
			if (keys.has(event.code)) {
				keys_down[is_down ? 'add' : 'delete'](event.code);
				if (!playing) return;
				event.preventDefault();
				let accel = 0;
				if (keys_down.has('ArrowUp')) accel++;
				if (keys_down.has('ArrowDown')) accel--;
				ws.send(JSON.stringify({
					type: 'position',
					x: Math.cos(angle) * accel,
					y: Math.sin(angle) * accel
				}));
			} else if (event.target !== chatinput && playing) chatinput.focus();
		}

		setInterval(() => {
			if (keys_down.has('ArrowLeft'))  angle -= Math.PI / 10;
			if (keys_down.has('ArrowRight')) angle += Math.PI / 10;
		}, 100);

		setInterval(update, 50);
		resize();
	}

	window.addEventListener('resize', resize);

	function resize() {
		let num = 99;
		play.style.width = '100%';
		while (num && document.documentElement.clientHeight <
			document.documentElement.scrollHeight) {
			play.style.width = (num--) + '%';
		}
	}
}
</script>

</html>